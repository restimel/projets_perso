<!DOCTYPE html>
<html>
<head>
	<meta charset="utf8">
	<title>JSON reader</title>
<!--
	This web file is a tool which helps to manipulate JSON object
	Original File : http://b.mariat.free.fr/tools/jsonReader.htm
	Author : Benoit Mariat
	Date : Dec 2011
	Last update : June 2012 (search from joker token and found an object from its value)
-->	
	<style>
		#corps header{
			font-weight : bold;
			font-size : 1.5em;
		}
		.openObject{
			display: block;
			border: 1px solid black;
			padding-left: 1.5em;
			margin-left:10px;
			box-shadow: 5px 5px 5px 0px #CCCCCC,inset 0px -1px 1px 0px #000000;
		}
		.closeObject{
			display:inline;
		}
		.objectContainer header{
			color: #0000FF;
			display: inline;
			padding: 5px;
			cursor: pointer;
			font-size : 1em;
		}
		.objectPresentation{
			margin-bottom : 2em;
		}
		
		.objectPresentation input{
			width : 100%;
			margin-top: 1em;
		}
		header.object:before{
			content: "⋆\a0\a0";
			font-size: xx-small;
			vertical-align: 30%;
			margin-left: -1.5em;
		}
		#corps #javascript{
			position: fixed;
			top: 10px;
			right: 10px;
			padding: 5px;
			box-shadow: 7px 7px 10px 5px #DDDDDD;
		}
		#corps #javascript input{
			height: 20px;
			font-style: italic;
			width: 95%;
		}
		#corps table{
			border : 4px solid black;
			border-collapse:collapse;
		}
		#corps th{
			border : 1px solid black;
			background-color : #AA33CC;
			padding : 0.3em;
		}
		#corps td{
			border : 1px solid black;
			padding : 0.25em;
		}
	</style>
</head>
<body>

<div id="corps">

	<section>
		<header>Code JSON</header>
		<label>JSON:<textarea id="source" placeholder="Code JSON to analyze" title="Update is done when loosing focus"></textarea></label>
		<label>Human readable:<textarea id="source2" placeholder="output JSON with indentation" title="Update is done when loosing focus"></textarea></label>
	</section>
	<hr style="width:50%">
	<section class="objectPresentation">
		<header>Objet hierarchy</header>
		<div id="objet" class="objectContainer"></div>
	</section>
	<hr>
	<section>
		<header>2nd Code JSON</header>
		<label>JSON:<textarea id="sourceBis" placeholder="Code JSON to analyze" title="Update is done when loosing focus"></textarea></label>
		<label>Human readable:<textarea id="sourceBis2" placeholder="output JSON with indentation" title="Update is done when loosing focus"></textarea></label>
	</section>
	<hr style="width:50%">
	<section class="objectPresentation">
		<header>Objet hierarchy</header>
		<div id="objetBis" class="objectContainer"></div>
	</section>
	<hr>
	<section>
		<header><label><input type="checkbox" id="comparaisonResultDoIt" checked/>Difference between JSON</header></label>
		<div id="comparaisonResult" class="comparaisonResult"></div>
	</section>

	<section id="javascript">
		<header>JavaScript code to access an element</header>
		<input id="codeJS" title="OBJ. désigne l'objet créé par JSON">&nbsp;</output>
	</section>

</div>

<script>

function countObj(myobj){
//permet de compter le nombre de propriétés de l'objet
	var count = 0,x;
	for (x in myobj) if (myobj.hasOwnProperty(x)) count++;
	return count;
}

function createLink(obj,elem,str){
//permet de créer les blocs d'ouverture
	return function(){
		if(elem.style.display=="block"){
			elem.style.display="none";
		}else{
			if(!elem.innerHTML){
				writeObj(obj,elem,str);
			}
			elem.style.display="block";
		}
	};
}

function writeObj(objet,element,str){
//permet d'afficher les propriétés sous formes d'éléments
	var elem,body,titre,x,code;
	element.innerHTML="";
	for(x in objet){
		titre=document.createElement("header");
		titre.textContent=x;
		elem=document.createElement("section");
		elem.className="closeObject";
		body=document.createElement("section");
		body.className="openObject";
		body.style.display="none";
		code = str+attributeToString(x);
		if(objet[x] === null){
			elem.textContent=" (null)";
		}else if(typeof objet[x] === "object"){
			if(objet[x] instanceof Array){
				elem.textContent=" (Array ["+objet[x].length+"])";
				if(objet[x].length>0) titre.onclick=createLink(objet[x],body,code);
			}else{
				var nb=countObj(objet[x]);
				elem.textContent=" ("+typeof objet[x]+" ["+nb+"])";
				if(nb>0) titre.onclick=createLink(objet[x],body,code);
			}
			titre.className = "object";
		}else if(typeof objet[x] === "string"){
			elem.textContent=" \""+objet[x]+"\" (string ["+objet[x].length+"])";
		}else{
			elem.textContent=" "+objet[x]+" ("+typeof objet[x]+")";
		}
		elem.onmouseover=(function(msg){
			return function(){document.getElementById("codeJS").value=msg;};
			})(code);
		element.appendChild(titre);
		element.appendChild(elem);
		element.appendChild(body);
		element.appendChild(document.createElement("br"));
	}
	element.className="openObject";
}

function jsonVerify(str,inside,offset){
//permet d'essayer de trouver les problèmes de code JSON
	var i=0,li=str.length,current,msg="",previous=inside;
	offset=offset||0;
	do{
		current=str[i];
		switch(current){
			case "{":
				if(inside==="\"" || inside==="'"){
					previous="";
					continue;
				}
				if(previous && "{}]\"';".indexOf(previous)!==-1){
					return "Character "+(i+offset+1)+": character {  should not be there.";
				}
				if(inside==="{" && previous===","){
					return "Character "+(i+offset+1)+": character { should not be placed before , when it is in an object (this object begins position "+offset+")";
				}
				
				msg=jsonVerify(str.substring(i+1),"{",i+offset+1);
				if(typeof msg ==="number"){
					i=msg-offset;
					previous="}";
				}else{
					return msg;
				}
				break;
			case "[":
				if(inside==="\"" || inside==="'"){
					previous="";
					continue;
				}
				if(previous && "{}]\"';".indexOf(previous)!==-1){
					return "Character "+(i+offset+1)+": charactere [  should not be there";
				}
				if(inside==="{" && previous===","){
					return "Character "+(i+offset+1)+": character [ should not be placed before , when it is in an object (this object begins position "+offset+")";
				}
				msg=jsonVerify(str.substring(i+1),"[",i+offset+1);
				if(typeof msg ==="number"){
					i=msg-offset;
					previous="]";
				}else{
					return msg;
				}
				break;
			case "]":
				if(inside==="\"" || inside==="'"){
					previous="";
					continue;
				}
				if(previous && "{,:;".indexOf(previous)!==-1 || inside!=="["){
					return "Character "+(i+offset+1)+": character ]  should not be there.";
				}
				return i+offset;
				break;
			case "}":
				if(inside==="\"" || inside==="'"){
					previous="";
					continue;
				}
				if(previous && "[,:;".indexOf(previous)!==-1 || inside!=="{"){
					return "Character "+(i+offset+1)+": character } should not be there.";
				}
				return i+offset;
				break;
			case "\"":
				if(inside==="'"){
					previous="";
					continue;
				}
				if(inside==="\""){
					if(previous ==="\\"){
						previous="";
					}else{
						return i+offset;
					}
				}else{
					if(previous && "}]\"';".indexOf(previous)!==-1){
						return "Character "+(i+offset+1)+": character \" should not be there";
					}
					msg=jsonVerify(str.substring(i+1),"\"",i+offset+1);
					if(typeof msg ==="number"){
						i=msg-offset;
						previous="\"";
					}else{
						return msg;
					}
				}
				break;
			case "'":
				if(inside==="\""){
					previous="";
					continue;
				}
				if(inside==="'"){
					if(previous ==="\\"){
						previous="";
					}else{
						return i+offset;
					}
				}else{
					if(previous && "}]\"';".indexOf(previous)!==-1){
						return "Character "+(i+offset+1)+": caracter ' should not be there";
					}
					msg=jsonVerify(str.substring(i+1),"'",i+offset+1);
					if(typeof msg ==="number"){
						i=msg-offset;
						previous="'";
					}else{
						return msg;
					}
				}
				break;
			
			case ",":
				if(inside==="\"" || inside==="'"){
					previous="";
					continue;
				}
				if(previous && "{[,:;".indexOf(previous)!==-1 || !inside){
					return "Character "+(i+offset+1)+": character , should not be there";
				}
				previous=",";
				break;
			case ":":
				if(inside==="\"" || inside==="'"){
					previous="";
					continue;
				}
				if(previous && "}]{[,:;".indexOf(previous)!==-1 || inside!=="{"){
					return "Character "+(i+offset+1)+": character : should not be there. In object "+inside+" position "+offset;
				}
				previous=":";
				break;
			
			case "\\":
				if(inside==="\"" || inside==="'"){
					if(previous==="\\") previous=""; else previous="\\";
				}else{
					return "Character "+(i+offset+1)+": character \\ should not be there";
				}
				break;
			default:
				if(inside==="\"" || inside==="'"){
					if(current!=="\n" && current!=="\r"){
						previous=current;
					}else{
						return "Character "+(i+offset+1)+": character end of line ("+(current==="\n"?"\\n":"\\r")+") should not be in a string. In object "+inside+" position "+offset;
					}
				}else{
					if("-1234567890".indexOf(current)!==-1 && ((inside==="{" && previous===":") || (inside==="[" && (previous==="," || previous==="[")))){
						previous=current;
					}else if("1234567890.".indexOf(current)!==-1 && "-1234567890.".indexOf(previous)!==-1){
						previous=current;
					}else{
						var ok=false;
						switch(current){
							case "n":
								if(inside==="{" && previous===":")ok="n";
								if(inside==="[" && previous===",")ok="n";
								if(inside==="[" && previous==="[")ok="n";
								break;
							case "u":
								if(previous==="n")ok="nu";
								break;
							case "l":
								if(previous==="nu")ok="nul";
								if(previous==="nul")ok="null";
								break;
							case "\n":
							case "\r":
							case "\t":
							case " ":
								ok=current;
								continue;
						}
						if(ok){
							previous=ok;
						}else{
							return "Character "+(i+offset+1)+": character "+current+" should not be there. In object "+inside+" position "+offset;
						}
						
					}
				}
		}
	}while(++i<li);
	if(inside) return "Character "+(i+offset)+": End of object not found, character "+inside+" was open at position "+offset+" and was not closed";
	else return "No problem detected";
	
}



function jsonReader(str,elem_id){
	var element=document.getElementById(elem_id);
	try{
		var obj=JSON.parse(str);
	}catch(e){
		var msg=jsonVerify(str,"",0),pst=(/Character (\d+).+(?:position (\d+))/i).exec(msg);
		element.innerHTML='<font color="red"><b>Format error</b></font>: '+e+"<br>"+msg+"<br><br>";
		if(pst){
			element.innerHTML+="<i>"+str.substring(0,pst[2]-1)+'<span style="color:blue;font-size:larger;">'+str.substring(pst[2]-1,pst[1]-1)+'</span><span style="color:red;font-size:larger;">'+str[pst[1]-1]+'</span>'+str.substring(pst[1])+"</i>";
		}else{
			pst=(/Character (\d+)/i).exec(msg);
			if(pst){
				element.innerHTML+="<i>"+str.substring(0,pst[1]-1)+'<span style="color:red;font-size:larger;">'+str[pst[1]-1]+'</span>'+str.substring(pst[1])+"</i>";
			}else{
				element.innerHTML+="<i>"+str+"</i>";
			}
		}
		return false;
	}
	if(obj===null){
		alert("No JSON object found");
		return false;
	}
	element.innerHTML="";
	var elem=document.createElement("section");
	//elem.className="openObject";
	writeObj(obj,elem,"OBJ");
	element.appendChild(elem);
	
	var recherche = document.createElement("input");
	recherche.type="text";
	recherche.title=recherche.placeholder="SEARCH: list values. Values should be written like JS objects and be separated by | use * from any member use = to found a content value; eg: arr[0]|arr[*]=1";
	recherche.onchange = function(){ //fonction de recherche
		zone_recherche.innerHTML="";
		if(this.value){
			var liste = this.value.split("|");
			var i=0, li=liste.length;
			var rslt=[];
			var searchComplet=[];
			var search = [];
			while(i<li){
				rslt[i]=[];
				searchComplet[i]=liste[i].replace(/([=])/,".$1.").split(/["']?\].|["']?\]\s*$|["']?\]\s*\[["']?|\[["']?|\./g);
				if(searchComplet[i][searchComplet[i].length-1] == ""){
					searchComplet[i].pop();
				}
				search.push(searchComplet[i][0]);
				i++;
			}
			function deepSch(obj,path,i,indice){ //recherche pour une colonne
				var index=indice||0,end=searchComplet[i].length;
				path = path || "";
				if(typeof obj !== "undefined" && obj !== null){
					while(++index<end && (typeof obj[searchComplet[i][index]] !== 'undefined')){
						path+="["+searchComplet[i][index]+"]";
						obj=obj[searchComplet[i][index]];
					}
				}else{
					index++;
				}
				if(index === end){
					rslt[i].push(obj)
				}else{
					//on vérifie si on est sur un caractère particulier
					var car=searchComplet[i][index];
					switch(searchComplet[i][index]){
						case "*" : //on accepte tous les attributs
							var x;
							for(x in obj){
								deepSch(obj[x],path+"["+x+"]",i,index);
							}
							break;
						case "=" : //on recherche le contenu
							if(obj==searchComplet[i][index+1] || searchComplet[i][index+1]==="*"){
								rslt[i].push(path); //le chemin permettant d'obtenir cette valeur
							}
					}
				}

			}
			function sch(o,path){
				var x,fromI,pth;
				path=path||"OBJ";
				for(x in o){
					pth=path+"["+x+"]";
					fromI=0;
					while(~search.indexOf(x,fromI)){//tant qu'on trouve une occurence de x dans search
						fromI = search.indexOf(x,fromI);
						deepSch(o[x],pth,fromI,0);//recherche en profondeur car le debut correspond
						fromI++;
					}
					fromI=0;
					while(~search.indexOf("*",fromI)){//tant qu'on trouve un joker dans search
						fromI = search.indexOf("*",fromI);
						deepSch(o[x],pth,fromI,0);//recherche en profondeur car le debut correspond
						fromI++;
					}
					if(typeof o[x] === 'object'){
						sch(o[x],pth);
					}
				}
			}
			sch(obj); //recherche des éléments
			
			//affichage du résultat
			//entete
			var table = document.createElement("table");
			var row = table.insertRow(-1);
			var cel;
			var i=0,li=liste.length;
			while(i<li){
				cel = document.createElement("th");
				cel.textContent = liste[i++];
				row.appendChild(cel);
			}
			
			//résultats
			var i=0, li=rslt.length, j=0, lj = rslt[0].length;
			while(j<lj){
				row = table.insertRow(-1);
				i=0;
				while(i<li){
					cel = row.insertCell(-1);
					cel.textContent=typeof rslt[i][j] === "undefined" ? "":rslt[i][j];
					i++;
				}
				j++;
			}
			
			zone_recherche.appendChild(table);
		}
	};
	element.appendChild(recherche);
	var zone_recherche = document.createElement("div");
	element.appendChild(zone_recherche);
	
	setTimeout(jsonCompare,50);
}

function searchObj(v,idObjet){
	var element=document.getElementById(idObjet);
	v=v.split(/"\].|"\]$|"\]\["|\["|\./g); //sépare tous les objets
	alert("la recherche d'objet n'a pas encore été réalisé :(")
	return false;
};

function readableJSON(str){
	var txt="";
	try{
		var txt=JSON.stringify(JSON.parse(str),null,"\t");
	}catch(e){
		txt = "";
	}
	return txt;
}

function jsonCompare(){
	var element=document.getElementById("comparaisonResult");
	element.innerHTML="";

	if(!document.getElementById("comparaisonResultDoIt").checked){
		//element.textContent = "Comparison disabled";
		return false;
	}
	
	var obj1 = document.getElementById("objet");
	var obj2 = document.getElementById("objetBis");
	
	//recherche obj1
	if(obj1.firstChild && obj1.firstChild.nodeName === "SECTION"){
		try{
			obj1 = JSON.parse(document.getElementById("source2").value);
		}catch(e){
			obj1 = JSON.parse(document.getElementById("source").value);
		}
	}else{
		obj1=null;
	}
	
	//recherche obj2
	if(obj2.firstChild && obj2.firstChild.nodeName === "SECTION"){
		try{
			obj2 = JSON.parse(document.getElementById("sourceBis2").value);
		}catch(e){
			obj2 = JSON.parse(document.getElementById("sourceBis").value);
		}
	}else{
		obj2=null;
	}
	
	if(obj1 && obj2){
		var rslt = compareObject(obj1,obj2);
		if(rslt){
			element.appendChild(rslt);
		}else{
			element.textContent = "No difference detected";
		}
	}else{
		element.textContent = "Not available while JSON codes are not readable";
	}
}

function compareObject(obj1,obj2,path,table){
	path = path || "";
	table = table || null;
	var x,liste=[];
	for(x in obj1){
		if(obj1.hasOwnProperty(x)){
			liste.push(x);
			if(typeof obj1[x] === typeof obj2[x]){
				if(typeof obj1[x] === "object"){
					table = compareObject(obj1[x],obj2[x],path+attributeToString(x),table);
				}else{
					if(obj1[x] !== obj2[x]){
						table = addDifference(table,path+attributeToString(x), obj1[x]+" ("+(typeof obj1[x])+")", obj2[x]+" ("+(typeof obj2[x])+")");
					}
				}
			}else{
				table = addDifference(table,path+attributeToString(x), obj1[x]+" ("+(typeof obj1[x])+")", obj2[x]+" ("+(typeof obj2[x])+")");
			}
		}
	}
	
	for(x in obj2){
		if(obj2.hasOwnProperty(x)){
			if(liste.indexOf(x) !== -1){
				continue;
			}
			if(typeof obj1[x] === typeof obj2[x]){
				if(typeof obj2[x] === "object"){
					table = compareObject(obj1[x],obj2[x],path+attributeToString(x),table);
				}else{
					if(obj1[x] !== obj2[x]){
						table = addDifference(table,path+attributeToString(x), obj1[x]+" ("+(typeof obj1[x])+")", obj2[x]+" ("+(typeof obj2[x])+")");
					}
				}
			}else{
				table = addDifference(table,path+attributeToString(x), obj1[x]+" ("+(typeof obj1[x])+")", obj2[x]+" ("+(typeof obj2[x])+")");
			}
		}
	}
	return table;
}

function addDifference(table,path,value1,value2){
	var row,cel;
	if(!table){
		table = document.createElement("table");
		row = table.insertRow(-1);
		cel = document.createElement("th");
		cel.textContent = "position";
		row.appendChild(cel);
		cel = document.createElement("th");
		cel.textContent = "Value 1";
		row.appendChild(cel);
		cel = document.createElement("th");
		cel.textContent = "Value 2";
		row.appendChild(cel);
	}
	
	row = table.insertRow(-1);
	cel = row.insertCell(-1);
	cel.textContent = path;
	
	cel = row.insertCell(-1);
	cel.textContent = value1;
	
	cel = row.insertCell(-1);
	cel.textContent = value2;
	
	return table;
}

function attributeToString(x){
	var code = "";
	if(/^[^_a-z]|[^a-z0-9_]/i.test(x)){
		if(isNaN(x)){
			code='["'+x.replace(/(["\\])/g,"\\$1")+'"]';
		}else{
			code='['+x+']';
		}
	}else{
		code='.'+x;
	}
	return code;
}


//ajout des événéments aux éléments
document.getElementById("source").onchange=function(event){
	jsonReader(this.value,'objet');
	document.getElementById('source2').value=readableJSON(this.value);
};
document.getElementById("source2").onchange=function(event){
	jsonReader(this.value,'objet');
	this.value=readableJSON(this.value);
};
document.getElementById("sourceBis").onchange=function(event){
	jsonReader(this.value,'objetBis');
	document.getElementById('sourceBis2').value=readableJSON(this.value);
};
document.getElementById("sourceBis2").onchange=function(event){
	jsonReader(this.value,'objetBis');
	this.value=readableJSON(this.value);
};
document.getElementById("codeJS").onchange=function(event){
	searchObj(this.value,'objet');
};
</script>

</body>
</html>
